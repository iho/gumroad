// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package pg

import (
	"context"
	"database/sql"
)

const createProduct = `-- name: CreateProduct :one
insert into public.products (
    name,
    price,
    description,
    summary,
    callToAction,
    coverImage,
    slug,
    isPablished,
    receipt,
    content,
    user_id
  )
values
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11
  ) returning id, user_id, price, name, description, summary, calltoaction, coverimage, slug, ispablished, receipt, content, created_at, updated_at
`

type CreateProductParams struct {
	Name         string         `json:"name"`
	Price        sql.NullInt32  `json:"price"`
	Description  sql.NullString `json:"description"`
	Summary      sql.NullString `json:"summary"`
	Calltoaction sql.NullString `json:"calltoaction"`
	Coverimage   sql.NullString `json:"coverimage"`
	Slug         sql.NullString `json:"slug"`
	Ispablished  bool           `json:"ispablished"`
	Receipt      sql.NullString `json:"receipt"`
	Content      sql.NullString `json:"content"`
	UserID       sql.NullInt32  `json:"user_id"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Name,
		arg.Price,
		arg.Description,
		arg.Summary,
		arg.Calltoaction,
		arg.Coverimage,
		arg.Slug,
		arg.Ispablished,
		arg.Receipt,
		arg.Content,
		arg.UserID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Price,
		&i.Name,
		&i.Description,
		&i.Summary,
		&i.Calltoaction,
		&i.Coverimage,
		&i.Slug,
		&i.Ispablished,
		&i.Receipt,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
select
  name,
  price,
  description,
  summary,
  callToAction,
  coverImage,
  slug,
  isPablished,
  receipt,
  content
from public.products
where
  id = $1
`

type GetProductRow struct {
	Name         string         `json:"name"`
	Price        sql.NullInt32  `json:"price"`
	Description  sql.NullString `json:"description"`
	Summary      sql.NullString `json:"summary"`
	Calltoaction sql.NullString `json:"calltoaction"`
	Coverimage   sql.NullString `json:"coverimage"`
	Slug         sql.NullString `json:"slug"`
	Ispablished  bool           `json:"ispablished"`
	Receipt      sql.NullString `json:"receipt"`
	Content      sql.NullString `json:"content"`
}

func (q *Queries) GetProduct(ctx context.Context, id int32) (GetProductRow, error) {
	row := q.db.QueryRowContext(ctx, getProduct, id)
	var i GetProductRow
	err := row.Scan(
		&i.Name,
		&i.Price,
		&i.Description,
		&i.Summary,
		&i.Calltoaction,
		&i.Coverimage,
		&i.Slug,
		&i.Ispablished,
		&i.Receipt,
		&i.Content,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
select
  p."name",
  p.price,
  p.description,
  p.summary,
  p.callToAction,
  p.coverImage,
  p.slug,
  p.isPablished,
  p.receipt,
  p.content
from public.products as p
`

type GetProductsRow struct {
	Name         string         `json:"name"`
	Price        sql.NullInt32  `json:"price"`
	Description  sql.NullString `json:"description"`
	Summary      sql.NullString `json:"summary"`
	Calltoaction sql.NullString `json:"calltoaction"`
	Coverimage   sql.NullString `json:"coverimage"`
	Slug         sql.NullString `json:"slug"`
	Ispablished  bool           `json:"ispablished"`
	Receipt      sql.NullString `json:"receipt"`
	Content      sql.NullString `json:"content"`
}

func (q *Queries) GetProducts(ctx context.Context) ([]GetProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsRow
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.Name,
			&i.Price,
			&i.Description,
			&i.Summary,
			&i.Calltoaction,
			&i.Coverimage,
			&i.Slug,
			&i.Ispablished,
			&i.Receipt,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
select id, username, name, bio, created_at, updated_at, last_active_at 
from public.users
where
  id = $1
`

func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastActiveAt,
	)
	return i, err
}
